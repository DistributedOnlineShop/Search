// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: search_index.sql

package db

import (
	"context"
)

const createSearchIndex = `-- name: CreateSearchIndex :one
INSERT INTO search_index(
    product_id,
    product_name,
    product_desc,
    product_attributes
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING product_id, product_name, product_desc, product_attributes, indexed_at
`

type CreateSearchIndexParams struct {
	ProductID         string `json:"product_id"`
	ProductName       string `json:"product_name"`
	ProductDesc       string `json:"product_desc"`
	ProductAttributes []byte `json:"product_attributes"`
}

func (q *Queries) CreateSearchIndex(ctx context.Context, arg CreateSearchIndexParams) (SearchIndex, error) {
	row := q.db.QueryRow(ctx, createSearchIndex,
		arg.ProductID,
		arg.ProductName,
		arg.ProductDesc,
		arg.ProductAttributes,
	)
	var i SearchIndex
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.ProductDesc,
		&i.ProductAttributes,
		&i.IndexedAt,
	)
	return i, err
}

const getSearchIndexByProductId = `-- name: GetSearchIndexByProductId :many
SELECT 
    product_id, product_name, product_desc, product_attributes, indexed_at 
FROM 
    search_index 
WHERE 
    product_id = $1
`

func (q *Queries) GetSearchIndexByProductId(ctx context.Context, productID string) ([]SearchIndex, error) {
	rows, err := q.db.Query(ctx, getSearchIndexByProductId, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchIndex{}
	for rows.Next() {
		var i SearchIndex
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.ProductDesc,
			&i.ProductAttributes,
			&i.IndexedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
